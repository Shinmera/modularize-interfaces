<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta charset="utf-8"/> <title>Modularize-Interfaces</title> <meta name="viewport" content="width=device-width"/> <meta name="description" content="Programmatical interfaces extension for Modularize"/> <meta name="author" content="Nicolas Hafner &lt;shinmera@tymoon.eu&gt;"/> <style type="text/css"> body{
          max-width: 1024px;
          margin: 0 auto 0 auto;
          font-family: sans-serif;
          color: #333333;
          font-size: 14pt;
          padding: 5px;
      }

      body>header{
          display:flex;
          align-items: center;
          justify-content: center;
          flex-direction: column;
          max-width: 100%;
      }

      img{
          max-width: 100%;
          max-height: 100%;
      }

      code{
          font-family: Consolas, Inconsolata, monospace;
      }

      a{
          text-decoration: none;
          color: #0055AA;
      }

      #documentation{
          text-align: justify;
      }

      #documentation pre{
          margin-left: 20px;
          overflow: auto;
      }

      #symbol-index>ul{
          list-style: none;
          padding: 0;
      }
      #symbol-index .package>ul{
          list-style: none;
          padding: 0 0 0 10px;
      }
      #symbol-index .package .nicknames{
          font-weight: normal;
      }
      #symbol-index .package h4{
          display: inline-block;
          margin: 0;
      }
      #symbol-index .package article{
          margin: 0 0 15px 0;
      }
      #symbol-index .package article header{
          font-size: 1.2em;
          font-weight: normal;
      }
      #symbol-index .package .name{
          margin-right: 5px;
      }
      #symbol-index .package .docstring{
          margin: 0 0 0 15px;
          white-space: pre-wrap;
          font-size: 12pt;
      }

      @media (max-width: 800px){
          body{font-size: 12pt;}
      } </style> </head> <body> <header> <h1>modularize-interfaces</h1> <span class="version">0.9.3</span> <p class="description">Programmatical interfaces extension for Modularize</p> </header> <main> <article id="documentation">  <div><h2>About Modularize-Interfaces</h2> <p>This is an extension to <a href="https://github.com/Shinmera/modularize">Modularize</a> that allows your application to define interfaces in-code that serve both as a primary documentation and as compliance control. Other modules can then implement interfaces to provide the actual functionality as outlined in the definition. A good example for a scenario in which this would be useful is databases. If other parts of the application can rely on a standardised interface it won't matter which database is really connected underneath and the type of database connection can be switched without having to change any of the other modules that rely on this functionality.</p> <h2>How To</h2> <p>Interfaces are defined through <code><a href="#MODULARIZE-INTERFACES:DEFINE-INTERFACE">DEFINE-INTERFACE</a></code>. These calls consist of a name (or a list of names) for the interface and a body of component definitions. You can define your own components, but more on that later. By default there are components for functions, macros, generic functions, methods and classes. A simple interface might look like so:</p> <pre><code>(<a href="#MODULARIZE-INTERFACES:DEFINE-INTERFACE">define-interface</a> radio
  (<a href="http://l1sp.org/cl/defun">defun</a> listen (frequency)
    &quot;Listens on a given frequency for radio signals and outputs them.&quot;)
  (<a href="http://l1sp.org/cl/defun">defun</a> scan ()
    &quot;Attempts to search the radio frequency range for recognisable signals.&quot;)
  (<a href="http://l1sp.org/cl/defun">defun</a> broadcast (station)
    &quot;Starts up the given radio station to broadcast.&quot;)
  (<a href="http://l1sp.org/cl/defmacro">defmacro</a> define-station ((name frequency) &amp;body body)
    &quot;Defines a new radio station on the given frequency.&quot;))</code></pre> <p>This will generate you an interface with the specified stub forms. Calling any of these functions before an implementation actually implements the interface will result in an error. In the back, <code><a href="#MODULARIZE-INTERFACES:DEFINE-INTERFACE">DEFINE-INTERFACE</a></code> creates a module through <code>DEFINE-MODULE</code> and then expands the specified components.</p> <p>If a module wants to implement an interface, it can define this in the <code>:IMPLEMENTS</code> module-option. It will then be automatically set up as the current implementation. Otherwise you can also directly do <code>(<a href="http://l1sp.org/cl/setf">SETF</a> (<a href="#MODULARIZE-INTERFACES:IMPLEMENTATION">IMPLEMENTATION</a> :interface) :my-module)</code>. If an interface is already implemented by another module, a condition is raised with restarts to either abort, delete the old module or override it. After an implementation is set, <code><a href="#MODULARIZE-INTERFACES:TEST-INTERFACE">TEST-INTERFACE</a></code> is called to check for compliance. Compliance checks must be implemented by the respective components and may or may not be sufficient to test for true interface compliance. If an implementing module gets deleted, <code><a href="#MODULARIZE-INTERFACES:RESET-INTERFACE">RESET-INTERFACE</a></code> is called, which returns it to its old state with error-ing stub definitions.</p> <p>Defining the actual components of the interface in your module works just like writing any other function or whatever part it is in effect. You may want to use the provided <code>I-*</code> macros for the standard components though to make the intent more visible.</p> <p>Adding new components to use in interface definition happens through <code><a href="#MODULARIZE-INTERFACES:DEFINE-COMPONENT-EXPANDER">DEFINE-COMPONENT-EXPANDER</a></code>. This should evaluate to whatever stub forms you need, optimally resulting in an error if a user tries to access it without a conforming implementation in place. Additionally you will most likely want to add a <code><a href="#MODULARIZE-INTERFACES:DEFINE-COMPONENT-TESTER">DEFINE-COMPONENT-TESTER</a></code> for each of your components. This is a simple function definition that is called whenever <code><a href="#MODULARIZE-INTERFACES:TEST-INTERFACE">TEST-INTERFACE</a></code> is invoked and should return two values, a boolean whether the test failed or not and a string that explains the reason for failure or passing. <code><a href="#MODULARIZE-INTERFACES:TEST-INTERFACE">TEST-INTERFACE</a></code> will convert this into warnings. It is discouraged to signal errors as this would prevent other components from being tested too and may interfere while developing an implementation.</p> <p>For a super small sample use of an interface, have a look at <a href="https://github.com/Shinmera/modularize-interfaces/blob/master/interfaces-test-implementation.asd">interfaces-test-implementation.asd</a>, <a href="https://github.com/Shinmera/modularize-interfaces/blob/master/interfaces-test-interface.lisp">interfaces-test-interface.lisp</a> and <a href="https://github.com/Shinmera/modularize-interfaces/blob/master/interfaces-test-implementation.lisp">interfaces-test-implementation.lisp</a>.</p> </div>  </article> <article id="copyright">  <h2>Copyright</h2> <span>modularize-interfaces</span> is licensed under the <span><a href="https://tldrlegal.com/search?q=Artistic">Artistic</a></span> license.  Â© <span>Nicolas Hafner &lt;shinmera@tymoon.eu&gt;</span> .  This library can be obtained on <a href="https://github.com/Shinmera/modularize-interfaces">https://github.com/Shinmera/modularize-interfaces</a>.  </article>  <article id="symbol-index"> <h2>Package Index</h2> <ul><li class="package"> <h3> <a name="MODULARIZE-INTERFACES" href="#MODULARIZE-INTERFACES">MODULARIZE-INTERFACES</a> <span class="nicknames">(INTERFACES ORG.SHIRAKUMO.RADIANCE.LIB.MODULARIZE.INTERFACES)</span> </h3> <ul><li> <a name="MODULARIZE-INTERFACES:INTERFACE-ALREADY-IMPLEMENTED"> </a> <article> <header class="condition"> <span class="type">condition</span>  <h4 class="name"><code><a href="#MODULARIZE-INTERFACES:INTERFACE-ALREADY-IMPLEMENTED">INTERFACE-ALREADY-IMPLEMENTED</a></code></h4>  </header> <pre class="docstring">Condition signalled if an interface is already implemented by a different module than was attempted to register as an implementation.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:INTERFACE-NOT-FOUND"> </a> <article> <header class="condition"> <span class="type">condition</span>  <h4 class="name"><code><a href="#MODULARIZE-INTERFACES:INTERFACE-NOT-FOUND">INTERFACE-NOT-FOUND</a></code></h4>  </header> <pre class="docstring">Condition signalled if an interface was requested but could not be found.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:COMPONENT-ALIAS"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:COMPONENT-ALIAS">COMPONENT-ALIAS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">ALIAS</code><code>)</code>  </header> <pre class="docstring">Returns the actual component name the given alias points to or itself if it is not resolved..</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:IMPLEMENTATION"> </a> <article> <header class="accessor"> <span class="type">accessor</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:IMPLEMENTATION">IMPLEMENTATION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INTERFACE</code><code>)</code>  </header> <pre class="docstring">Returns the currently active implementation of the interface.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:GENERATE-INTERFACE-STUB"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:GENERATE-INTERFACE-STUB">GENERATE-INTERFACE-STUB</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INTERFACE &amp;OPTIONAL (PACKAGE *PACKAGE*)</code><code>)</code>  </header> <pre class="docstring">Generates a stub for the INTERFACE that you can use as an implementation starting point.
Symbols are interned into PACKAGE where appropriate.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:IMPLEMENTS"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:IMPLEMENTS">IMPLEMENTS</a></code></h4> <code class="qualifiers"></code> <code class="arguments">MODULE</code><code>)</code>  </header> <pre class="docstring">Returns a list of interfaces this module implements.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:INTERFACE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:INTERFACE">INTERFACE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">Returns the interface package module as identified by the object.
See MODULE for more.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:INTERFACE-P"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:INTERFACE-P">INTERFACE-P</a></code></h4> <code class="qualifiers"></code> <code class="arguments">OBJECT</code><code>)</code>  </header> <pre class="docstring">Returns T if the passed object is or names an interface, otherwise NIL.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:PRINT-INTERFACE-STUB"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:PRINT-INTERFACE-STUB">PRINT-INTERFACE-STUB</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INTERFACE &amp;OPTIONAL (PACKAGE *PACKAGE*)</code><code>)</code>  </header> <pre class="docstring">Print the stub of GENERATE-INTERFACE-STUB in a way that is easily copy-pastable.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:RESET-INTERFACE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:RESET-INTERFACE">RESET-INTERFACE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INTERFACE</code><code>)</code>  </header> <pre class="docstring">Resets the interface by redefining it with stubs as per its component definitions.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:TEST-INTERFACE"> </a> <article> <header class="function"> <span class="type">function</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:TEST-INTERFACE">TEST-INTERFACE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">INTERFACE</code><code>)</code>  </header> <pre class="docstring">Tests the interface for definition conformity. See TEST-COMPONENTS.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:EXPAND-COMPONENT"> </a> <article> <header class="generic"> <span class="type">generic</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:EXPAND-COMPONENT">EXPAND-COMPONENT</a></code></h4> <code class="qualifiers"></code> <code class="arguments">TYPE ARGS &amp;KEY INTERFACE &amp;ALLOW-OTHER-KEYS</code><code>)</code>  </header> <pre class="docstring">Generic function used to expand components into their proper forms.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:DEFIMPL"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:DEFIMPL">DEFIMPL</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Expands to I-DEFMACRO, I-DEFMETHOD or I-DEFUN depending on what kind of symbol it names.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:DEFINE-COMPONENT-EXPANDER"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:DEFINE-COMPONENT-EXPANDER">DEFINE-COMPONENT-EXPANDER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Defines a new component expander for interface definitions.

The NAME can be a list of names that will be aliased to the first one.
All names will be turned into keywords to allow for differing naming schemes
in the component definitions. INTERFACE should be a symbol to which the
interface package is bound. ARGUMENTS is the lambda-list used to deconstruct
the arguments of the component definition.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:DEFINE-COMPONENT-TESTER"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:DEFINE-COMPONENT-TESTER">DEFINE-COMPONENT-TESTER</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Defines a new testing method for a component type.

The structure of this macro is the same as for DEFINE-COMPONENT.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:DEFINE-INTERFACE"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:DEFINE-INTERFACE">DEFINE-INTERFACE</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Defines a new interface.

This defines a new module with the given name and nicks, as well
as a fully qualified interface identifier which is the name prefixed
by MODULARIZE.INT. . It then calls EXPAND-INTERFACE on the new module
and finally expands the component definitions as per EXPAND-COMPONENTS.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:DEFINE-INTERFACE-EXTENSION"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:DEFINE-INTERFACE-EXTENSION">DEFINE-INTERFACE-EXTENSION</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Currently not implemented.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:DEFMACRO*"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:DEFMACRO*">DEFMACRO*</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Expands to a conditional macro definition that only happens if
either *REDEFINE* is T or the macro has not yet been defined.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:DEFMETHOD*"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:DEFMETHOD*">DEFMETHOD*</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Expands to a conditional method definition that only happens if
either *REDEFINE* is T or the method has not yet been defined.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:DEFUN*"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:DEFUN*">DEFUN*</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Expands to a conditional function definition that only happens if
either *REDEFINE* is T or the function has not yet been defined.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:I-DEFMACRO"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:I-DEFMACRO">I-DEFMACRO</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Expands to an interface macro definition.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:I-DEFMETHOD"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:I-DEFMETHOD">I-DEFMETHOD</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Expands to an interface method definition.</pre> </article> </li><li> <a name="MODULARIZE-INTERFACES:I-DEFUN"> </a> <article> <header class="macro"> <span class="type">macro</span>  <code>(</code><h4 class="name"><code><a href="#MODULARIZE-INTERFACES:I-DEFUN">I-DEFUN</a></code></h4> <code class="qualifiers"></code> <code class="arguments">&amp;REST ARGS</code><code>)</code>  </header> <pre class="docstring">Expands to an interface function definition.</pre> </article> </li></ul> </li></ul> </article>  </main> </body> </html> 